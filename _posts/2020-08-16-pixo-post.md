---
layout: post
title: "픽소 개발팀이 협업을 하는 방법"
description: "픽소 개발팀의 협업 방식에 대하여 간략하게 이야기해 보고자 합니다."
date: 2020-08-16
tags: []
comments: true
share: true
---
 
개발자라면 누구나 다양한 개발자들과 같이 일하면서 함께 성장할 수 있는 환경을 꿈꿉니다. 

같은 언어와 같은 플랫폼을 다루며 공통의 문제를 해결해 나가는 동료야말로 든든한 지원군이고 가장 가까운 스승이죠.

## 픽소의 iOS팀
픽소는 메인 프로덕트인 [로고샵](https://apps.apple.com/kr/app/로고샵-로고만들기-로고-그래픽-디자인/id1190077343)과 [베이비스토리](https://apps.apple.com/kr/app/베이비그램-육아-포토북/id1068110571)를 비롯해 모두 8종의 iOS 어플리케이션을 글로벌 타겟으로 서비스 하고 있습니다.  

![큰 이미지](/images/pixo_app.png)

대부분의 프로덕트가 꾸준하고 두터운 사용자층을 확보하고 있는 덕에 픽소는 4명의 iOS 개발자가 함께 팀을 이루어 일을 하고 있습니다. 그리고 앞으로도 멋진 개발자가 있다면 언제든 함께 할 계획입니다.  

4명의 개발자가 **재미있게, 잘** 개발하기 위해 어떻게 일을 하는지, 뚝딱뚝딱 언제나 최적화중인 픽소 개발팀에 대해 이야기해 보고자 합니다.  

<iframe src="https://giphy.com/embed/3WakpYN5tiFXO" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/jump-cheezburger-rope-3WakpYN5tiFXO">via GIPHY</a></p>

## 애자일하게
픽소의 개발팀은 애자일 프로세스 기반으로 일을 합니다.

주 단위의 스프린트와 회고를 통해 팀 프로세스를 개선하고 태스크 플래닝을 통해 다음 스프린트를 계획합니다. 

유저 스토리를 토대로 이슈를 생성하고 스토리 포인트로 대략적인 일정을 산출하기도 합니다. 

가볍고 기민하게 일을 하기 위해서 부가적으로 소요되는 작업들을 의식적으로 간결하게 하면서, 이제 주 단위 릴리즈도 척척 할 수 있을 것이고 업무 퍼포먼스도 향상될 것이라 기대했습니다.

우리는 한 때 스스로 애자일하게 일한다고 착각하던 때가 있었습니다. 

스프린트를 정하고 태스크를 분배하고 코딩을 하고 회고를 하며 매주 개선을 해나가고 있었으니까요.

하지만 스프린트와 회고를 한다고 해서 그것이 애자일하게 일한다는 것은 아니라는 것을 머지않아 깨닫게 되었습니다.

예상치 못하게 거대해지는 태스크와 모호한 스펙, 쌓여가는 PR에 지쳐갈 때 쯤 우리는 스스로에게 묻게 되었습니다.

## 왜 애자일하지 않지?
왜 애자일하지 않지? 애자일? 너는 대체 무엇?  
애자일 방식이라는 건 대체 무엇 일까요. 사전에는 아래와 같이 정의하고 있습니다. 
> 기민하고 민첩한. 
> 
![큰 이미지](/images/agile.png)

우리가 애자일한 조직이라면 재빠르게 개발을 해서 날렵하게 사용자에게 제공할 수 있어야 합니다.  

사용자는 매 주 발전하는 서비스를 접하며 만족감을 느끼게 될 것이고, 우리를 더욱 신뢰하여 지속적인 사용을 약속하게 될 것입니다. (그렇습니다. 구독말입니다)  

우리는 애자일하기 위해서는 코딩 그 자체에 집중 해야 한다고 생각했습니다.   

문서를 최소화하고 규율을 간소화하고 부족한 부분은 커뮤니케이션으로 해결하면 된다고 생각했죠.  

하지만 결론적으로 우리가 맞닥뜨린 문제점은 결국 최소화한 스펙정의 혹은 문서, 그리고 간소화된 규율에 있었습니다.  

## 부작용
픽소가 맞닥뜨린 문제점들에 대해 살펴보도록 하겠습니다.  

1. Task `사이즈`에 대한 예측 실패
2. `구체적이지 않은 스펙`으로 인한 커뮤니케이션 비용의 증대
3. Task가 `비대`한 경우 Code Reivew와 User Test에 대한 부담
4. Task가 `비대`한 경우 Side Effect의 증가
5. 릴리즈 일정 지연

우리는 매주 Task Planning Meeting에서 Backlog에 모아놓은 Task를 각자 가져갑니다.  
이 때 Task의 사이즈가 모두에게 동일하지 않았다는게 첫번째 원인이었습니다.  

### 아주 나쁜 예를 들어보겠습니다.  

1. Task에 assign 합니다.  
2. 스펙정의가 `간략`합니다. (일정 예측이 어렵습니다)  
3. 개발을 위해 구체적인 스펙을 정의 합니다. (커뮤니케이션에 할애하는 시간이 커집니다)  
4. 왜때문에 커뮤니케이션을 할 수록 태스크가 `불어납니다`.  
5. 코딩을 합니다. (시간이 많이 듭니다)  
6. PR을 합니다.  
7. 다른 개발자가 PR을 위한 코드 리뷰를 합니다. (시간이 많이 듭니다)  
8. 코드를 병합니다.   
9. 이미 릴리즈 일정은 이미 지연되었고 다른 태스크의 진행도 지연되었습니다  

## 태스크가 잘못했네!
태스크의 사이즈가 클 경우 개발, 리뷰, 테스트에 시간이 많이 소요됩니다.  
👉 당연한 일입니다.  

태스크의 스펙이 너무 간략하면 구체화하기 위해 커뮤니케이션을 더 많이 해야합니다.  
👉 하지만 코로나 시대의 커뮤니케이션은 **더욱 어려워졌죠** 😢  

개발을 완료 하더라도 PR이라는 또 다른 산이 남아있습니다.  
👉 픽소는 개발팀 모두가 리뷰 후 승인하기 때문에 **모두의 시간이 사용**됩니다.  

사이드 이펙트에 대한 예측이 어려워 QA에 대한 부담이 커집니다.  
👉 릴리즈한 앱이 **죽는다는 리포트**를 받는 나쁜 상상을 해봅니다. 🥶   

눈치채셨나요? 우리는 이러한 문제점들을 마주하면서 모두 하나의 지점을 바라보고 있다는 것을 알게 되었습니다.  

네 그렇습니다! 태스크가 문제였습니다!   

태스크가 작아지면 그 이후의 플로우가 모두 가벼워질테니까요. 하지만 어떻게 작게 만들어야 할지 고민이 시작되었습니다. 

## 고민없이 무조건 쪼개고 시작하는건 어떨까?
태스크가 할당되면 개발자는 Spec을 읽고 그에 맞는 본인만의 개발계획을 수립할 것입니다.  
이 때 우리는 수립한 개발 계획을 바탕으로 무조건 세분화하자는 규칙을 정했습니다.   

만약 간단할 것이라고 생각되어 만들어진 태스크가 예상치 못하게 커지더라도 다른 개발자와 협업이 쉬워질 것이고 리뷰를 기다리는 시간이 줄어들 것이라고 생각했습니다.  

픽소의 개발팀은 Task와 github issue, branch를 동기화하여 작업을 합니다.  
따라서 Task가 하나의 issue가 되고 이 issue가 곧 하나의 branch가 됩니다.  
그리고 기본적인 Git Flow 전략을 따르고 있으므로 대부분의 경우 develop이 base branch가 됩니다.  

하지만 Sub Task가 만들어진다면 이런 전략이 조금 바뀌게 됩니다.  

## Task 세분화 전략

### 아주 좋은 예를 들어보겠습니다.  

1. Task에 assign 합니다.  
2. 개발계획을 세웁니다.  
3. 관련기능에 대한 리서치 부터 실질적인 코딩까지 이 때 세운 개발계획은 `곧 Sub-Task`가 됩니다.  
4. 이 Sub-Task는 `1시간 이내에 리뷰`할 수 있는 정도의 코드여야 합니다.  
5. Task와 Sub-Task의 종속관계처럼 branch도 동일한 구조로 생성합니다. (Main Task → Sub Task, Main Branch → Sub Branch)  
6. 필요하다면 다른 개발자가 Sub-Task 작업을 도울 수 있습니다. (Task Owner가 좋아합니다 😃)  
7. Sub Branch의 개발이 끝난 후 Main Branch로 병합하기 위한 PR을 합니다.  
8. 이 때의 리뷰는 `코드에 집중`합니다 (리뷰어가 좋아합니다 😃)  
9. 모든 Sub Branch의 개발이 완료되면 Main Branch를 develop에 병합하기 위한 PR을 합니다.  
10. 이 때의 리뷰는 `기능검토에 집중`합니다 (리뷰어가 좋아합니다 😃)  
11. 세분화된 Task 계획에 맞게 릴리즈 `일정을 예측`할 수 있습니다. (개발팀이 좋아합니다 😃)  

## Spec의 구체화 
이제 두번째 문제점, 모호한 Spec을 해결해야 합니다.   

전통적인 폭포수 방식의 개발에서는 특정한 역할을 맡은 사람이(가령 PM, 기획자) 많은 부분을 해결해 주고 있지만 픽소는 소수의 구성원이 함께 비지니스의 방향을 고민합니다.  

그래서 디자이너, 마케터 혹은 개발자 등 픽소의 구성원 모두가 Task를 생성할 수 있는 구조입니다.  

그렇다보니 개발자가 생성한 Task가 아니라면 구현의 상세 Spec까지 완벽하게 정의한다는 것은 **현실성이 없는** 이야기입니다.  

## Requirements, Spec, Context
그렇다면 Spec이 어떠한 방식으로 쓰여져야 하는지, Assignee에게 최종적으로 무엇이 전달되어야 하는지 고민할 필요가 있었습니다.  

Spec의 가이드라인을 정하고 누가 어디까지 작성해야 하는지 최소한의 규칙을 정한다면 비어있는 컨텍스트로 인해 커뮤니케이션 오류가 발생하는 것을 방지할 수 있을 것입니다.  

픽소는 다음의 분류로 스펙을 구체화하기로 하였습니다.  
- **Requirements**  
    - `feature` 구현해야 하는 것에 대해 설명  
    - `debug` 오류에 대해 수정해야 하는 것에 대해 설명  
    - `priority` 작업의 우선 순위 (user story point)  
- **Spec**  
  Requirements를 완료하기 위한 구체적인 명세  
    
- **Context or Purpose**  
    Requirements의 이해와 확장을 위해 제공해야 하는 부가적인 설명  

어떻게 보면 당연해보이는 분류와 설명처럼 보이죠.  

하지만 실제로 이 가이드를 적용하고 난 후 커뮤니케이션은 훨씬 단순해졌습니다. (당연함의 기준은 각자 다를 수 있는 법😬)  

이제 진화된 Task Strategy를 통한 진정한 애자일을 경험해보는 일만 남아있습니다.  

# 맺으며

제가 개발자로서 픽소에 합류한지 어느덧 1년이라는 시간이 지났습니다.  
1년동안 함께 토론하고 문화를 다지며 픽소 개발팀은 많은 성장을 이루어 나가고 있습니다.  

같은 목표를 가진 팀에서 개발을 하고 문화를 만들어간다는 것은 참으로 멋진 경험이 아닐 수 없습니다.  

원래 그런 것은 없고, 늘 그래야만 하는 것을 경계하는 픽소답게 우리는 수 많은 방법론과 가설속에서 우리에게 맞는 방법을 늘 찾아가고 있습니다. (다시 또 새로운 Task Strategy가 등장할지도 몰라요)  

앞으로 함께 방법을 고민하고 제품을 만들 멋진 개발자들과 다 같이 성장할 미래가 매우 기대됩니다.  

그리고, 픽소 개발팀의 최적화는 앞으로도 계속될거에요. 쭈욱 😎  






